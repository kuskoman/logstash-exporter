name: Cleanup Untagged Images

on:
  # Commented out for testing purposes - will be uncommented later
  # schedule:
  #   # Run every Monday at 1:00 AM
  #   - cron: '0 1 * * 1'

  # For testing on this specific branch
  push:
    branches:
      - cleanup-untagged-images

  # Allow manual triggering
  workflow_dispatch:

permissions:
  packages: write
  contents: read

jobs:
  cleanup:
    name: Cleanup untagged container images
    runs-on: ubuntu-latest
    env:
      DRY_RUN: "true"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: List and analyze container images
        id: analyze_images
        run: |
          echo "Fetching ALL package versions..."

          # Set up variables for pagination
          PAGE=1
          PER_PAGE=100
          ALL_VERSIONS=()

          # GitHub repository owner (organization or user)
          REPO_OWNER="${GITHUB_REPOSITORY_OWNER}"
          echo "Repository owner: $REPO_OWNER"

          # Determine if this is a user or organization repository
          # First try with user endpoint
          echo "Trying to fetch using user endpoint..."
          USER_ENDPOINT="/users/$REPO_OWNER/packages/container/logstash-exporter/versions?per_page=$PER_PAGE&page=1"
          ORG_ENDPOINT="/orgs/$REPO_OWNER/packages/container/logstash-exporter/versions?per_page=$PER_PAGE&page=1"

          # Test user endpoint
          USER_TEST=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$USER_ENDPOINT" 2>/dev/null || echo "")

          if [ -n "$USER_TEST" ]; then
            echo "Using user endpoint for package versions"
            API_ENDPOINT_TEMPLATE="/users/$REPO_OWNER/packages/container/logstash-exporter/versions?per_page=$PER_PAGE&page=PLACEHOLDER"
          else
            echo "Using organization endpoint for package versions"
            API_ENDPOINT_TEMPLATE="/orgs/$REPO_OWNER/packages/container/logstash-exporter/versions?per_page=$PER_PAGE&page=PLACEHOLDER"
          fi

          # Get all versions with pagination (both tagged and untagged)
          while true; do
            echo "Fetching page $PAGE..."

            # Replace placeholder with actual page number
            API_ENDPOINT="${API_ENDPOINT_TEMPLATE/PLACEHOLDER/$PAGE}"

            # Get a page of package versions (all versions)
            PAGE_RESULT=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "$API_ENDPOINT" || echo "[]")

            # If empty result or no elements in array, we've reached the end of pagination
            if [ -z "$PAGE_RESULT" ] || [ "$(echo "$PAGE_RESULT" | jq '. | length')" = "0" ]; then
              echo "No more results on page $PAGE"
              break
            fi

            # Append results to our array
            ALL_VERSIONS+=("$PAGE_RESULT")

            # Move to next page
            PAGE=$((PAGE + 1))
          done

          # Create a combined JSON array from all pages
          COMBINED_RESULTS=$(echo "${ALL_VERSIONS[@]}" | jq -s 'add')

          # Count total fetched versions
          VERSIONS_COUNT=$(echo "$COMBINED_RESULTS" | jq 'length')
          echo "Fetched $VERSIONS_COUNT total package versions"

          # If no versions found, exit early
          if [ "$VERSIONS_COUNT" = "null" ] || [ "$VERSIONS_COUNT" = "0" ]; then
            echo "No package versions found. Check package name and permissions."
            echo "versions_to_delete=[]" >> $GITHUB_OUTPUT
            echo "versions_to_keep=[]" >> $GITHUB_OUTPUT
            echo "versions_to_delete_details=[]" >> $GITHUB_OUTPUT
            echo "all_version_details=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Analyzing versions..."

          # Process versions into arrays for keeping and deleting
          # Using temporary files to avoid shell variable limitations
          VERSIONS_TO_KEEP=()
          VERSIONS_TO_DELETE=()
          ALL_DETAILS=()

          # Get the current date in ISO format
          CURRENT_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "Current date: $CURRENT_DATE"

          # Calculate cutoff date (28 days ago) in ISO format
          CUTOFF_DATE=$(date -u -d "28 days ago" +"%Y-%m-%dT%H:%M:%SZ")
          echo "Cutoff date: $CUTOFF_DATE"

          # Process all versions
          KEEP_COUNTER=0
          DELETE_COUNTER=0

          # Use a simple loop without subshells to avoid variable scope issues
          COUNT=$(echo "$COMBINED_RESULTS" | jq 'length')
          for ((i=0; i<$COUNT; i++)); do
            VERSION=$(echo "$COMBINED_RESULTS" | jq -c ".[$i]")

            VERSION_ID=$(echo "$VERSION" | jq -r '.id')
            CREATED_AT=$(echo "$VERSION" | jq -r '.created_at')
            NAME=$(echo "$VERSION" | jq -r '.name')
            TAGS=$(echo "$VERSION" | jq -r '.metadata.container.tags | join(", ")')
            HAS_TAGS=$(echo "$VERSION" | jq -r '.metadata.container.tags | length > 0')

            # Create a detailed record for reporting
            DETAIL=$(jq -n \
              --arg id "$VERSION_ID" \
              --arg name "$NAME" \
              --arg created "$CREATED_AT" \
              --arg tags "$TAGS" \
              --argjson has_tags "$HAS_TAGS" \
              '{id: $id, name: $name, created_at: $created, tags: $tags, has_tags: $has_tags}')

            ALL_DETAILS+=("$DETAIL")

            # Decide whether to keep or delete based on tags and age
            if [ "$HAS_TAGS" = "true" ]; then
              # Always keep tagged versions
              echo "Keeping tagged version $VERSION_ID ($NAME) with tags: $TAGS"
              VERSIONS_TO_KEEP+=("$DETAIL")
              KEEP_COUNTER=$((KEEP_COUNTER + 1))
            elif [[ "$CREATED_AT" < "$CUTOFF_DATE" ]]; then
              # Delete untagged versions older than 28 days
              echo "Marking for deletion: Version $VERSION_ID ($NAME) created at $CREATED_AT (older than 28 days)"
              VERSIONS_TO_DELETE+=("$DETAIL")
              DELETE_COUNTER=$((DELETE_COUNTER + 1))
            else
              # Keep untagged versions newer than 28 days
              echo "Keeping recent untagged version $VERSION_ID ($NAME) created at $CREATED_AT"
              VERSIONS_TO_KEEP+=("$DETAIL")
              KEEP_COUNTER=$((KEEP_COUNTER + 1))
            fi
          done

          echo "Analysis complete:"
          echo "- Total versions: $((KEEP_COUNTER + DELETE_COUNTER))"
          echo "- Versions to keep: $KEEP_COUNTER"
          echo "- Versions to delete: $DELETE_COUNTER"

          # Convert arrays to JSON for output
          if [ ${#VERSIONS_TO_DELETE[@]} -eq 0 ]; then
            echo "No versions to delete found."
            DELETE_DETAILS_JSON="[]"
            DELETE_IDS_JSON="[]"
          else
            DELETE_DETAILS_JSON=$(printf '%s\n' "${VERSIONS_TO_DELETE[@]}" | jq -s '.')
            DELETE_IDS_JSON=$(printf '%s\n' "${VERSIONS_TO_DELETE[@]}" | jq -s '[.[] | .id]')
          fi

          if [ ${#VERSIONS_TO_KEEP[@]} -eq 0 ]; then
            echo "No versions to keep found."
            KEEP_JSON="[]"
          else
            KEEP_JSON=$(printf '%s\n' "${VERSIONS_TO_KEEP[@]}" | jq -s '.')
          fi

          if [ ${#ALL_DETAILS[@]} -eq 0 ]; then
            echo "No version details found."
            ALL_DETAILS_JSON="[]"
          else
            ALL_DETAILS_JSON=$(printf '%s\n' "${ALL_DETAILS[@]}" | jq -s '.')
          fi

          # Save outputs in compact format (single line JSON)
          echo "versions_to_delete=$(echo $DELETE_IDS_JSON | jq -c '.')" >> $GITHUB_OUTPUT
          echo "versions_to_keep=$(echo $KEEP_JSON | jq -c '.')" >> $GITHUB_OUTPUT
          echo "versions_to_delete_details=$(echo $DELETE_DETAILS_JSON | jq -c '.')" >> $GITHUB_OUTPUT
          echo "all_version_details=$(echo $ALL_DETAILS_JSON | jq -c '.')" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Dry run - Display detailed analysis
        run: |
          echo "=================== DRY RUN ANALYSIS ==================="

          # Count different types of versions
          TOTAL_COUNT=$(echo '${{ steps.analyze_images.outputs.all_version_details }}' | jq 'length')
          DELETE_COUNT=$(echo '${{ steps.analyze_images.outputs.versions_to_delete }}' | jq 'length')
          KEEP_COUNT=$(echo '${{ steps.analyze_images.outputs.versions_to_keep }}' | jq 'length')

          echo "Total versions analyzed: $TOTAL_COUNT"
          echo "Versions to keep: $KEEP_COUNT"
          echo "Versions to delete: $DELETE_COUNT"

          if [ "$DELETE_COUNT" -gt "0" ]; then
            echo ""
            echo "-------------- VERSIONS TO BE DELETED ----------------"
            echo '${{ steps.analyze_images.outputs.versions_to_delete_details }}' | \
              jq -r '.[] | "ID: \(.id) | Created: \(.created_at) | \(.name)"' | sort
          else
            echo ""
            echo "No versions to delete."
          fi

          if [ "$KEEP_COUNT" -gt "0" ]; then
            echo ""
            echo "-------------- VERSIONS TO BE KEPT ------------------"
            echo '${{ steps.analyze_images.outputs.versions_to_keep }}' | \
              jq -r '.[] | "ID: \(.id) | Created: \(.created_at) | Tags: \(.tags) | \(.name)"' | sort
          else
            echo ""
            echo "No versions to keep."
          fi

          echo ""
          echo "This is a DRY RUN. No images will be deleted."
          echo "To perform actual deletion, set DRY_RUN to 'false' and uncomment the deletion step."
          echo "======================================================"

      # Uncomment this step to actually delete the versions when ready
      # - name: Delete filtered package versions
      #   if: env.DRY_RUN == 'false' && fromJSON(steps.analyze_images.outputs.versions_to_delete) != []
      #   uses: actions/delete-package-versions@v4
      #   with:
      #     package-name: 'logstash-exporter'
      #     package-type: 'container'
      #     package-version-ids: ${{ steps.analyze_images.outputs.versions_to_delete }}
      #     token: ${{ secrets.GITHUB_TOKEN }}
