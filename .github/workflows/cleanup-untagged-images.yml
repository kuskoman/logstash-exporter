name: Cleanup Untagged Images

on:
  # Commented out for testing purposes - will be uncommented later
  # schedule:
  #   # Run every Monday at 1:00 AM
  #   - cron: '0 1 * * 1'

  # For testing on this specific branch
  push:
    branches:
      - cleanup-untagged-images

  # Allow manual triggering
  workflow_dispatch:

permissions:
  packages: write
  contents: read

jobs:
  cleanup:
    name: Cleanup untagged container images
    runs-on: ubuntu-latest
    env:
      DRY_RUN: "false"
      BATCH_SIZE: 20 # Process 20 IDs at a time

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: List and analyze container images
        id: analyze_images
        run: |
          echo "Fetching ALL package versions..."

          # Set up variables for pagination
          PAGE=1
          PER_PAGE=100
          ALL_VERSIONS=()

          # GitHub repository owner (organization or user)
          REPO_OWNER="${GITHUB_REPOSITORY_OWNER}"
          echo "Repository owner: $REPO_OWNER"

          # Determine if this is a user or organization repository
          # First try with user endpoint
          echo "Trying to fetch using user endpoint..."
          USER_ENDPOINT="/users/$REPO_OWNER/packages/container/logstash-exporter/versions?per_page=$PER_PAGE&page=1"
          ORG_ENDPOINT="/orgs/$REPO_OWNER/packages/container/logstash-exporter/versions?per_page=$PER_PAGE&page=1"

          # Test user endpoint
          USER_TEST=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$USER_ENDPOINT" 2>/dev/null || echo "")

          if [ -n "$USER_TEST" ]; then
            echo "Using user endpoint for package versions"
            API_ENDPOINT_TEMPLATE="/users/$REPO_OWNER/packages/container/logstash-exporter/versions?per_page=$PER_PAGE&page=PLACEHOLDER"
          else
            echo "Using organization endpoint for package versions"
            API_ENDPOINT_TEMPLATE="/orgs/$REPO_OWNER/packages/container/logstash-exporter/versions?per_page=$PER_PAGE&page=PLACEHOLDER"
          fi

          # Get all versions with pagination (both tagged and untagged)
          while true; do
            echo "Fetching page $PAGE..."

            # Replace placeholder with actual page number
            API_ENDPOINT="${API_ENDPOINT_TEMPLATE/PLACEHOLDER/$PAGE}"

            # Get a page of package versions (all versions)
            PAGE_RESULT=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "$API_ENDPOINT" || echo "[]")

            # If empty result or no elements in array, we've reached the end of pagination
            if [ -z "$PAGE_RESULT" ] || [ "$(echo "$PAGE_RESULT" | jq '. | length')" = "0" ]; then
              echo "No more results on page $PAGE"
              break
            fi

            # Append results to our array
            ALL_VERSIONS+=("$PAGE_RESULT")

            # Move to next page
            PAGE=$((PAGE + 1))
          done

          # Create a combined JSON array from all pages
          COMBINED_RESULTS=$(echo "${ALL_VERSIONS[@]}" | jq -s 'add')

          # Count total fetched versions
          VERSIONS_COUNT=$(echo "$COMBINED_RESULTS" | jq 'length')
          echo "Fetched $VERSIONS_COUNT total package versions"

          # If no versions found, exit early
          if [ "$VERSIONS_COUNT" = "null" ] || [ "$VERSIONS_COUNT" = "0" ]; then
            echo "No package versions found. Check package name and permissions."
            echo "versions_to_delete=[]" >> $GITHUB_OUTPUT
            echo "versions_to_keep=[]" >> $GITHUB_OUTPUT
            echo "versions_to_delete_details=[]" >> $GITHUB_OUTPUT
            echo "all_version_details=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Analyzing versions..."

          # Process versions into arrays for keeping and deleting
          # Using temporary files to avoid shell variable limitations
          VERSIONS_TO_KEEP=()
          VERSIONS_TO_DELETE=()
          ALL_DETAILS=()
          VERSION_IDS_TO_DELETE=()

          # Get the current date in ISO format
          CURRENT_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "Current date: $CURRENT_DATE"

          # Calculate cutoff date (28 days ago) in ISO format
          CUTOFF_DATE=$(date -u -d "28 days ago" +"%Y-%m-%dT%H:%M:%SZ")
          echo "Cutoff date: $CUTOFF_DATE"

          # Process all versions
          KEEP_COUNTER=0
          DELETE_COUNTER=0

          # Use a simple loop without subshells to avoid variable scope issues
          COUNT=$(echo "$COMBINED_RESULTS" | jq 'length')
          for ((i=0; i<$COUNT; i++)); do
            VERSION=$(echo "$COMBINED_RESULTS" | jq -c ".[$i]")

            VERSION_ID=$(echo "$VERSION" | jq -r '.id')
            CREATED_AT=$(echo "$VERSION" | jq -r '.created_at')
            NAME=$(echo "$VERSION" | jq -r '.name')
            TAGS=$(echo "$VERSION" | jq -r '.metadata.container.tags | join(", ")')
            HAS_TAGS=$(echo "$VERSION" | jq -r '.metadata.container.tags | length > 0')

            # Create a detailed record for reporting - ensure ID is stored as number
            DETAIL=$(jq -n \
              --argjson id "$VERSION_ID" \
              --arg name "$NAME" \
              --arg created "$CREATED_AT" \
              --arg tags "$TAGS" \
              --argjson has_tags "$HAS_TAGS" \
              '{id: $id, name: $name, created_at: $created, tags: $tags, has_tags: $has_tags}')

            ALL_DETAILS+=("$DETAIL")

            # Decide whether to keep or delete based on tags and age
            if [ "$HAS_TAGS" = "true" ]; then
              # Always keep tagged versions
              echo "Keeping tagged version $VERSION_ID ($NAME) with tags: $TAGS"
              VERSIONS_TO_KEEP+=("$DETAIL")
              KEEP_COUNTER=$((KEEP_COUNTER + 1))
            elif [[ "$CREATED_AT" < "$CUTOFF_DATE" ]]; then
              # Delete untagged versions older than 28 days
              echo "Marking for deletion: Version $VERSION_ID ($NAME) created at $CREATED_AT (older than 28 days)"
              VERSIONS_TO_DELETE+=("$DETAIL")
              # Store numeric ID for deletion
              VERSION_IDS_TO_DELETE+=($VERSION_ID)
              DELETE_COUNTER=$((DELETE_COUNTER + 1))
            else
              # Keep untagged versions newer than 28 days
              echo "Keeping recent untagged version $VERSION_ID ($NAME) created at $CREATED_AT"
              VERSIONS_TO_KEEP+=("$DETAIL")
              KEEP_COUNTER=$((KEEP_COUNTER + 1))
            fi
          done

          echo "Analysis complete:"
          echo "- Total versions: $((KEEP_COUNTER + DELETE_COUNTER))"
          echo "- Versions to keep: $KEEP_COUNTER"
          echo "- Versions to delete: $DELETE_COUNTER"

          # Convert arrays to JSON for output
          if [ ${#VERSIONS_TO_DELETE[@]} -eq 0 ]; then
            echo "No versions to delete found."
            DELETE_DETAILS_JSON="[]"
            DELETE_IDS_JSON="[]"
          else
            DELETE_DETAILS_JSON=$(printf '%s\n' "${VERSIONS_TO_DELETE[@]}" | jq -s '.')
            # Store all IDs to delete
            DELETE_IDS_JSON=$(echo "${VERSION_IDS_TO_DELETE[@]}" | jq -c -n '[inputs]')
            echo "IDs to delete (raw format): $DELETE_IDS_JSON"

            # Create batches of IDs for deletion
            BATCH_SIZE=${BATCH_SIZE:-20}
            TOTAL_IDS=${#VERSION_IDS_TO_DELETE[@]}
            NUM_BATCHES=$(( (TOTAL_IDS + BATCH_SIZE - 1) / BATCH_SIZE ))

            echo "Splitting $TOTAL_IDS IDs into $NUM_BATCHES batches of up to $BATCH_SIZE IDs each"

            # Create JSON for each batch
            for ((i=0; i<$NUM_BATCHES; i++)); do
              START=$((i * BATCH_SIZE))
              END=$((START + BATCH_SIZE))
              if [ $END -gt $TOTAL_IDS ]; then
                END=$TOTAL_IDS
              fi

              BATCH=()
              for ((j=START; j<END; j++)); do
                BATCH+=(${VERSION_IDS_TO_DELETE[$j]})
              done

              BATCH_JSON=$(echo "${BATCH[@]}" | jq -c -n '[inputs]')
              echo "batch_${i}=$BATCH_JSON" >> $GITHUB_OUTPUT
            done

            echo "num_batches=$NUM_BATCHES" >> $GITHUB_OUTPUT
          fi

          if [ ${#VERSIONS_TO_KEEP[@]} -eq 0 ]; then
            echo "No versions to keep found."
            KEEP_JSON="[]"
          else
            KEEP_JSON=$(printf '%s\n' "${VERSIONS_TO_KEEP[@]}" | jq -s '.')
          fi

          if [ ${#ALL_DETAILS[@]} -eq 0 ]; then
            echo "No version details found."
            ALL_DETAILS_JSON="[]"
          else
            ALL_DETAILS_JSON=$(printf '%s\n' "${ALL_DETAILS[@]}" | jq -s '.')
          fi

          # Save outputs in compact format (single line JSON)
          echo "versions_to_delete=$DELETE_IDS_JSON" >> $GITHUB_OUTPUT
          echo "versions_to_keep=$(echo $KEEP_JSON | jq -c '.')" >> $GITHUB_OUTPUT
          echo "versions_to_delete_details=$(echo $DELETE_DETAILS_JSON | jq -c '.')" >> $GITHUB_OUTPUT
          echo "all_version_details=$(echo $ALL_DETAILS_JSON | jq -c '.')" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Display analysis
        run: |
          echo "=================== ANALYSIS SUMMARY ==================="

          # Count different types of versions
          TOTAL_COUNT=$(echo '${{ steps.analyze_images.outputs.all_version_details }}' | jq 'length')
          DELETE_COUNT=$(echo '${{ steps.analyze_images.outputs.versions_to_delete }}' | jq 'length')
          KEEP_COUNT=$(echo '${{ steps.analyze_images.outputs.versions_to_keep }}' | jq 'length')

          echo "Total versions analyzed: $TOTAL_COUNT"
          echo "Versions to keep: $KEEP_COUNT"
          echo "Versions to delete: $DELETE_COUNT"

          if [ "$DELETE_COUNT" -gt "0" ]; then
            echo ""
            echo "Found $DELETE_COUNT versions to delete in ${{ steps.analyze_images.outputs.num_batches }} batches"

            # Don't print all deletion details if there are too many
            if [ "$DELETE_COUNT" -lt "50" ]; then
              echo ""
              echo "-------------- VERSIONS TO BE DELETED ----------------"
              echo '${{ steps.analyze_images.outputs.versions_to_delete_details }}' | \
                jq -r '.[] | "ID: \(.id) | Created: \(.created_at) | \(.name)"' | sort
            else
              echo ""
              echo "Too many versions to display ($DELETE_COUNT). Showing first 10:"
              echo '${{ steps.analyze_images.outputs.versions_to_delete_details }}' | \
                jq -r '.[:10] | .[] | "ID: \(.id) | Created: \(.created_at) | \(.name)"' | sort
            fi
          else
            echo ""
            echo "No versions to delete."
          fi

          echo ""
          if [ "${{ env.DRY_RUN }}" = "true" ]; then
            echo "This is a DRY RUN. No images will be deleted."
          else
            echo "LIVE RUN! Images WILL be deleted."
          fi
          echo "======================================================"

      # Process batches of IDs to delete
      - name: Delete package versions (batch processing)
        if: env.DRY_RUN == 'false' && steps.analyze_images.outputs.num_batches > 0
        run: |
          NUM_BATCHES=${{ steps.analyze_images.outputs.num_batches }}
          echo "Processing $NUM_BATCHES batches of package versions for deletion"

          for ((i=0; i<$NUM_BATCHES; i++)); do
            BATCH_VAR="batch_${i}"
            BATCH_IDS=$(echo '${{ toJSON(steps.analyze_images.outputs) }}' | jq -r --arg batch "$BATCH_VAR" '.[$batch]')

            if [ -z "$BATCH_IDS" ] || [ "$BATCH_IDS" = "null" ]; then
              echo "Skipping empty batch $i"
              continue
            fi

            echo "Processing batch $i with IDs: $BATCH_IDS"

            # Use GitHub CLI to delete the batch of versions
            # This is more reliable than the action for handling batches
            for VERSION_ID in $(echo "$BATCH_IDS" | jq -r '.[]'); do
              echo "Deleting version ID: $VERSION_ID"

              # Using GitHub CLI to delete the package version
              ENDPOINT_PATH=$([ "$API_ENDPOINT_TEMPLATE" == *"/users/"* ] && echo "/users/" || echo "/orgs/")
              ENDPOINT="${ENDPOINT_PATH}${GITHUB_REPOSITORY_OWNER}/packages/container/logstash-exporter/versions/${VERSION_ID}"

              DELETE_RESULT=$(gh api --method DELETE \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "$ENDPOINT" 2>&1 || echo "ERROR: Failed to delete version $VERSION_ID")

              if [[ "$DELETE_RESULT" == *"ERROR"* ]]; then
                echo "WARNING: $DELETE_RESULT"
              else
                echo "Successfully deleted version $VERSION_ID"
              fi

              # Add a small delay to avoid rate limiting
              sleep 0.5
            done

            echo "Completed batch $i"
          done

          echo "Package version cleanup completed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
